// 存储持续性、作用域、链接性
/*
1.自动存储持续性
默认情况：函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。
代码块：定义变量，存在时间和作用域仅在代码块内
（1）初始化
其值为已知的表达式来初始化自动变量
（2）自动变量和栈
自动变量存储在栈（内存里）中，使用两个指针维护栈。栈底--栈的开始位置（出），堆顶--下一个可用内存单元。
寄存器变量：register int count_fact;目前的作用仅仅是显式指出变量是自动的。

2.静态持续变量
所有静态变量在程序执行期间都存在，未经初始化的静态变量均被设置为0（零初始化的）。
（1）外部链接性：可在其他文件中访问，代码块外声明
通常称为"外部变量"，存储持续性为静态，作用域为整个文件，可以在main()前面和头文件中定义，可以在任何函数中使用，因此外部变量也被称为"全局变量"。
只能在一个文件中定义一次，在其他文件中使用 extern 声明它就可以正常使用。
局部变量将隐藏全局变量，使用作用域解析运算符::，表示使用的是变量的全局版本。
全局变量会使得程序不可靠，避免对数据进行不必要的访问能够保证数据的完整性。通常情况下尽可能使用局部变量。
全局变量适合存储常量数据，使用const来防止数据被修改。
const char * char monst[12]={"January","February","March","April","May","June","July","August","September","October","Nobember","December"};
第一个const防止字符串被修改，第二个const确保每个指针都指向它最初的字符串。

（2）内部链接性：只能在当前文件中访问，代码块外部使用static声明
static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的，称为"静态外部变量"。在多文件程序中，链接性为内部的只能在所属的文件中使用。
在文件中，静态外部变量将隐藏常规外部变量。
注意：使用外部变量在多文件程序的不同部分之间共享数据。使用静态外部变量在同一个文件中的多个函数之间共享数据。

（3）无链接性：只能在当前函数或代码块中访问，代码块内使用static声明
无链接的局部变量：在代码块中使用static，局部变量的存储持续性为静态，该变量只在代码段中使用，但它在代码块不活跃的时间状态时仍然存在。
在两次函数调用之间，静态局部变量的值将保持不变。可以用于记录读取的字符总数。

3.说明符和限定符
存储说明符或cv-限定符
(1)auto:指出变量为自动变量，在c++11之前用于自动类型推断
(2)register:寄存器存储，在c++以后显式指出变量是自动的
(3)static:作用域为整个文件中时，表示内部链接性。用于局部声明中时，表示局部变量的存储持续性为静态的。
(4)extern:表示引用声明，声明引用在其他地方定义的变量，
(5)thread_local:指出变量的持续性和其所属线程的持续性相同。
(6)mutable:根据const来解释。

3.1 cv-限定符
c:const
v:volatile
const表示内存被初始化后就不能再修改
volatile表示即使程序代码没有对内存单元进行修改，其值也可能发生改变。如：一个指针指向某个硬件位置，包含了来自串行端口的时间和信息，硬件（不是软件）则可能修改了其中的内容。
或者两个程序相互影响，共享数据。关键字的作用是为了改善编译器的优化能力。

3.2 mutable
可以用mutable来指出，即使结构（或类）变量为const,其某个成员也可以被修改：
struct data{
    char name[20];
    mutable int accesses;
}
const data veep = {"Clayboune Clodde",0,...};
strcpy(veep.name, "Joye Joux");
veep.accesses++;

3.3 const
在c++，const限定符对默认存储类型稍有影响。默认情况下，全局变量的链接性为外部的，但const全局变量的链接性为内部的。在c++看来，全局const定义就像使用了static说明符一样.
const int fingers = 10;
static const int fingers = 10;
常量定义放在头文件中，常量会在多个文件中使用，预处理器会将头文件的内容包含到每个源文件中，但全局变量只能进行一次定义，因此会转化为static。
此时所有文件都有自己的一组常量，而不是所有文件共享一组常量。每个定义都是文件私有，
如果程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性。
extern const int status = 50;
在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它。
在函数或代码块中声明const时，作用域为代码块，不必担心其与其他地方的常量发生冲突。

4.函数和链接性
函数也有链接性，c++不允许一个函数中定义另外的函数，因此所有的函数存储持续性自动默认为静态的。即在整个程序执行期间都存在。
默认情况下，函数的链接性是外部的，即可以在文件间共享。可以在函数原型中使用extern来指出函数是在另一个文件中定义的。
还可以使用static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义中使用static
static int private(double x);
static int private(double x)
{
    ... 
}
此时该函数只在该文件中可见，其他文件可定义同名函数。和静态变量一样，静态函数也会隐藏外部定义，即使在外部使用了相同的同名函数，该文件仍将使用静态函数。
非内联函数，程序只能包含一个定义。对于链接性是外部的函数而言，只能有一个文件包含了函数定义。但使用该函数的每个文件都应该包含函数原型。
内联函数不受约束，可以将其放在头文件中，文件的每个文件都有内联函数的定义。c++要求所有的内联定义都必须相同。

5.语言链接性
链接程序要求每个程序都要有不同的符号名。c中一个名字对应一个函数，c++中一个名字可能对应多个函数，c执行c语言链接性，c++进行名称矫正和名称修饰。
可以使用函数原型来指出要使用的约定：
extern "c" void spiff(int);     // 使用c语言链接性
extern void spiff(int);         // 默认方式使用c++
extern "c++" void spiff(int);   // 显式使用c++

6. 存储方案和动态分配
编译器使用三块独立的内存：(1)静态变量（可能细分）(2)自动变量(3)动态变量，用于动态储存
6.1 使用new运算符初始化
（1）为内置的标量类型分配存储空间并初始化：在堆(heap)中找到一个足以能够满足要求的内存块。
int *pi = new int (6);
double * pd = new double (99.99);
（2）初始化常规结构或数组：
struct where{double x; double y; double z;};
where * one = new where {2.5, 5.3, 7.2};
int * ar = new int [4] {2,4,6,7};
6.2 new失败时
new可能找不到请求的内存量，c++早期是返回空指针，现在引发异常 std::bad_alloc
6.3 new: 运算符、函数和替换函数
运算符new和new[]分别调用如下函数：
void * operator new(std::size_t);
void * operator new[](std::size_t);
这些函数被称为分配函数，位于全局名称空间中。也有delete和delete[]的释放函数：
void operator delete(void *)
void operator delete[](void *)
举例：
int * pi = new int;
被转化为：
int * pi = new(sizeof(int));
而
int * pi = new int[40];
int * pi = new(40 * sizeof(int));

6.4 定位new运算符
new的另一种用法是定位运算new运算符，指定要使用的位置。
首先包含头文件new，然后将new运算符用于提供了所需地址的参数。

#include<iostream>
#include <new>

struct chaff{
    char dross[20];
    int slag;
};
char buffer1[50];
char buffer2[500];
int main()
{
    chaff *p1, *p2;
    int *p3, *p4;
    p1 = new chaff;                 // 在堆中放置chaff结构
    p2 = new int[20];               // 在堆中放置int数组
    p3 = new (buffer1) chaff;       // 在buffer1中放置chaff结构
    p4 = new (buffer2) int[20];     // 在buffer2中放置int数组
}

常规new调用一个接受一个参数的new()，标准定位 new()调用一个接受两个参数的new()函数。

*/

