/*
3 处理数据
    c++变量的命名规则：
    C++内置的整型--unsigned long、long、unsigned int、int、unsigned short、short、char、unsigned char、signed char、bool
    C++11新增的整型:unsigned long long、long long
    表示各种整形的系统限制的climits文件；
    各种整型的数字字面值(常量)
    使用const限定符来创建符号常量；
    C++内置的浮点类型--float、double、long double
    表示各种浮点类型的系统限制的cfloat文件
    各种浮点类型的数字字面值
    c++的算术运算符
    自动类型转换
    强制类型转换
*/

/*
3.1 简单变量
3.1.1 变量名
c++变量的命名规则：
    名称中只能使用字母字符、数字和下划线。
    名称的第一个字符不能是数字。
    区分大小写
    不能将关键字用作名称
    以两个下划线打头或者以下划线和大写字母打头的名称被保留给实现(编译器及其使用的资源)。
    以一个下划线开头的名称被保留给实现，用作全局标识符。
    一般长度没有限制，有点编译器有限制。

命名方案：
    前缀：字符串：str/s 布尔值:b 指针:p 单个字符:c

3.1.2 整型
术语宽度:表示存储整型时使用的内存量
C++基本整型为(宽度递增)：char、short、int、long、long long
short:至少2字节
int:至少与short一样长
long:至少4字节，且至少和int一样长
long long:至少8字节，且至少和long一样长

1.运算符sizeof 和 头文件 limits
运算符：sizeof
    sizeof(int); 返回int的字节数
    sizeof n_short; 也可以不使用括号
头文件:limits
    定义了符号常量来表示类型的限制。
    例如：
    CHAR_BIT    char的位数
    CHAR_MAX    char的最大值
    CHAR_MIN    char的最小值

2.初始化：将赋值和声明合并在一起
int n_int;      声明
n_int = 1;      赋值
int n_int = 1;  初始化
int n_int(5);   初始化变体

3.c++11 初始化方式
int hamburgers = {24}; // 可用于数组和结构，也可用于单值变量
int emus{7};           // 也可以不用等号
int rocs = {};         // 也可以不含任何内容，默认赋值为0
int pstchics{};

3.1.6 整型字面值
C++计数系统：
    C++使用前一(两)位来标识数字常量的基数。
    第一位0~9 则基数为10
    第一位0,第二位为1~7 则基数为8(八进制)
    前两位为 0x 或 0X, 则基数为16(16进制)

默认条件下，cout仅以十进制的方式显示整数
    dec：十进制
    hex：十六进制
    oct：八进制
cout << hec << hex << oct; 切换输出模式

3.1.8 char类型:字符和小整数
char类型时专为存储字符而设计的。
char最常被用来处理字符，但可以将它用来处理比short更小的整型。

ASCII字符集：
A：65

cout.put(); 显示一个字符

6.wchar_t
    8位的char可以表示基本字符集
    16位的wchar_t可以表示扩展字符集
wcout 和 wcin 提供了处理 wchar_t流
可以使用前缀 L 来指示宽字符常量和宽字符串：L'P' L"tall"

7.C++11 新增的类型：char16_t char32_t
char16_t:无符号 16位 前缀u u'q' u"be good"      与\u00F6 通用字符名匹配
char32_t:无符号 32位 前缀U U'R' U"dirty rat"    与\U0000222B通用字符名匹配  U'/U0000222B'

3.1.9 bool类型
bool:逻辑字符
true:1
false:0
*/

/*
3.2 const 限定符
创建常量：
    const int name = value;
    {
        错误格式：
        const int toes;
        toes = 10;
        如果常量声明时没有提供值，则不能再初始化，此时常量的值不确定。
    }
*/

/*
3.3 浮点数
C++两种书写浮点数的方法：
    标准小数点表示法：12.34 0.00023
    E表示法：2.52e+8 8.33E-4

3.3.2 浮点类型
C++3种浮点类型：float、double、long double 
float:4字节
double:8字节
long double:80、96、128位等
指数范围：至少 -37~37

3.3.3 浮点常量
float:f/F后缀           1.234f
double:正常/2.4E8       2.2345E28
long double:l/L后缀     2.2L

3.3.4 浮点数的优缺点
优点：    
    表示整数之间的值
    有放缩因子，表示的范围大得多
缺点：
    计算慢
    精度降低

整型和浮点型 统称 算术类型
*/

/*
3.4 C++算术运算符
+:加
-:减
*:乘
/:除
%:求模

3.4.1 运算符优先级
附录D

3.4.2 除法分支
除法运算符/行为取决于操作数的类型。
*/

/*
C语言中的类型转换
    C语言和C++都是强类型语言，如果赋值运算符左右两侧变量的类型不同，或形参与实参的类型不匹配，或返回值类型与接收返回值的变量类型不一致，那么就需要进行类型转换。
    C语言中有两种形式的类型转换，分别是隐式类型转换和显式类型转换：
        隐式类型转换：编译器在编译阶段自动进行，能转就转，不能转就编译失败。
        显式类型转换：需要用户自己处理，以(指定类型)变量的方式进行类型转换。
    需要注意的是，只有相近类型之间才能发生隐式类型转换，比如int和double表示的都是数值，只不过它们表示的范围和精度不同。
    而指针类型表示的是地址编号，因此整型和指针类型之间不会进行隐式类型转换，如果需要转换则只能进行显式类型转换。
    {
        //隐式类型转换
	    int i = 1;
	    double d = i;

        //显式类型转换
	    int* p = &i;
	    int address = (int)p;
    }
    
    为什么C++需要四种类型转换:
    C风格的转换格式虽然很简单，但也有很多缺点：

    隐式类型转换在某些情况下可能会出问题，比如数据精度丢失。
    显式类型转换将所有情况混合在一起，转换的可视性比较差。
    因此C++为了加强类型转换的可视性，引入了四种命名的强制类型转换操作符，分别是static_cast、reinterpret_cast、const_cast和dynamic_cast。

    C++强制类型转换
    1.static_cast
    static_cast用于相近类型之间的转换，编译器隐式执行的任何类型转换都可用static_cast，但它不能用于两个不相关类型之间转换。
    {
        static_cast <type-id> (expression)
        将expression转换为type-id类型，主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：
        1.用于类层次结构中，基类和子类之间指针和引用的转换；
        当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；(以多表少，子代表父 是安全的)
        当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；(以少表多，以父表子，是不安全的)
        2.用于基本数据类型之间的转换，如把int转换成char，把int转换成enum等等，这种转换的安全性需要程序员来保证；
        3.把void指针转换成目标类型的指针，是及其不安全的；

        

        注：static_cast不能转换掉expression的const、volatile和__unaligned属性。
    }

    2.reinterpret_cat
    reinterpret_cast用于两个不相关类型之间的转换。
    还有一个非常bug的用法，比如在下面的代码中将带参带返回值的函数指针转换成了无参无返回值的函数指针，并且还可以用转换后函数指针调用这个函数。
    说明一下： 用转换后的函数指针调用该函数时没有传入参数，因此这里打印出参数i的值是一个随机值。

    3.const_cast
    const_cast用于删除变量的const属性，转换后就可以对const变量的值进行修改。

    说明一下：
    代码中用const_cast删除了变量a的地址的const属性，这时就可以通过这个指针来修改变量a的值。
    由于编译器认为const修饰的变量是不会被修改的，因此会将const修饰的变量存放到寄存器当中，当需要读取const变量时就会直接从寄存器中进行读取，而我们修改的实际上是内存中的a的值，因此最终打印出a的值是未修改之前的值。
    如果不想让编译器将const变量优化到寄存器当中，可以用volatile关键字对const变量进行修饰，这时当要读取这个const变量时编译器就会从内存中进行读取，即保持了该变量在内存中的可见性。

    4.dynamic_cast
    dynamic_cast用于将父类的指针（或引用）转换成子类的指针（或引用）。
    向上转型与向下转型

向上转型： 子类的指针（或引用）→ 父类的指针（或引用）。
向下转型： 父类的指针（或引用）→ 子类的指针（或引用）。

其中，向上转型就是所说的切割/切片，是语法天然支持的，不需要进行转换，而向下转型是语法不支持的，需要进行强制类型转换。

向下转型的安全问题



*/